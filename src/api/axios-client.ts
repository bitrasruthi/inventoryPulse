//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

//-----ClientClass--AuthControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class AuthControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    login(body: SignInDto, cancelToken?: CancelToken | undefined): Promise<Anonymous> {
        let url_ = this.baseUrl + "/auth/login";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    setUserCustomerRole(cusId: string, roleId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/set-user-customer-role/{cusId}/{roleId}";
        if (cusId === undefined || cusId === null)
          throw new Error("The parameter 'cusId' must be defined.");
        url_ = url_.replace("{cusId}", encodeURIComponent("" + cusId));
        if (roleId === undefined || roleId === null)
          throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetUserCustomerRole(_response);
        });
    }

    protected processSetUserCustomerRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getCookies( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/get-cookies";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCookies(_response);
        });
    }

    protected processGetCookies(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getMe( cancelToken?: CancelToken | undefined): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/auth/me";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMe(_response);
        });
    }

    protected processGetMe(response: AxiosResponse): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous2>(null as any);
    }
}

//-----/ClientClass----

export * as AuthControllerQuery from './axios-client/AuthControllerQuery';



//-----ClientClass--UsersControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class UsersControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    addUser(body: CreateUserRequestDto, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/createUser";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getUsers(body: GetUserRequestDto, cancelToken?: CancelToken | undefined): Promise<UserPaginationResponse> {
        let url_ = this.baseUrl + "/users/get";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<UserPaginationResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserPaginationResponse.fromJS(resultData200);
            return Promise.resolve<UserPaginationResponse>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = UserPaginationResponse.fromJS(resultData201);
            return Promise.resolve<UserPaginationResponse>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserPaginationResponse>(null as any);
    }
}

//-----/ClientClass----

export * as UsersControllerQuery from './axios-client/UsersControllerQuery';



//-----ClientClass--InspectionControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class InspectionControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    save(body: InspectionRequestDto, cancelToken?: CancelToken | undefined): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/inspection/save";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous3>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous3>(null as any);
    }
}

//-----/ClientClass----

export * as InspectionControllerQuery from './axios-client/InspectionControllerQuery';



//-----ClientClass--PropertyControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class PropertyControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    save(body: PropertyRequestDto, cancelToken?: CancelToken | undefined): Promise<Anonymous4> {
        let url_ = this.baseUrl + "/property/save";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<Anonymous4> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous4>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous4>(null as any);
    }

    getProperties(body: PaginationRequest, cancelToken?: CancelToken | undefined): Promise<PropertyPaginationResponse> {
        let url_ = this.baseUrl + "/property/get";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: AxiosResponse): Promise<PropertyPaginationResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyPaginationResponse.fromJS(resultData200);
            return Promise.resolve<PropertyPaginationResponse>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = PropertyPaginationResponse.fromJS(resultData201);
            return Promise.resolve<PropertyPaginationResponse>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyPaginationResponse>(null as any);
    }
}

//-----/ClientClass----

export * as PropertyControllerQuery from './axios-client/PropertyControllerQuery';



//-----ClientClass--CustomerControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class CustomerControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    createCustomer(body: CreateCustomerDto, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/createCustomer";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCustomer(_response);
        });
    }

    protected processCreateCustomer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getCustomerByIs(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/getCustomerById/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCustomerByIs(_response);
        });
    }

    protected processGetCustomerByIs(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

//-----/ClientClass----

export * as CustomerControllerQuery from './axios-client/CustomerControllerQuery';



//-----ClientClass--ClientControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class ClientControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    create(body: ClientDto, cancelToken?: CancelToken | undefined): Promise<Anonymous5> {
        let url_ = this.baseUrl + "/client/save";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous5>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous5>(null as any);
    }

    getClients(body: PaginationRequest, cancelToken?: CancelToken | undefined): Promise<ClientPaginationResponse> {
        let url_ = this.baseUrl + "/client/get";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetClients(_response);
        });
    }

    protected processGetClients(response: AxiosResponse): Promise<ClientPaginationResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClientPaginationResponse.fromJS(resultData200);
            return Promise.resolve<ClientPaginationResponse>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = ClientPaginationResponse.fromJS(resultData201);
            return Promise.resolve<ClientPaginationResponse>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientPaginationResponse>(null as any);
    }
}

//-----/ClientClass----

export * as ClientControllerQuery from './axios-client/ClientControllerQuery';



//-----ClientClass--ContactControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class ContactControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    save(body: ContactRequestDto, cancelToken?: CancelToken | undefined): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/contact/createContact";
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous6>(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous6>(null as any);
    }

    getContacts(id: string, cancelToken?: CancelToken | undefined): Promise<Anonymous7> {
        let url_ = this.baseUrl + "/contact/getContactsByInspectionId/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetContacts(_response);
        });
    }

    protected processGetContacts(response: AxiosResponse): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<Anonymous7>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous7>(null as any);
    }

    delete(id: string, cancelToken?: CancelToken | undefined): Promise<CustomResponse> {
        let url_ = this.baseUrl + "/contact/deleteByContactId/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<CustomResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomResponse.fromJS(resultData200);
            return Promise.resolve<CustomResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomResponse>(null as any);
    }
}

//-----/ClientClass----

export * as ContactControllerQuery from './axios-client/ContactControllerQuery';



//-----ClientClass--StaticControllerClient---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class StaticControllerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getStaticData( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/static/getStaticData";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStaticData(_response);
        });
    }

    protected processGetStaticData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

//-----/ClientClass----

export * as StaticControllerQuery from './axios-client/StaticControllerQuery';



//-----Types.File-----
export class CustomResponse implements ICustomResponse {
    data!: any | undefined;
    success!: boolean;
    statusCode!: number;
    message!: string;

    [key: string]: any;

    constructor(data?: ICustomResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"];
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CustomResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data;
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        return data;
    }
}

export interface ICustomResponse {
    data: any | undefined;
    success: boolean;
    statusCode: number;
    message: string;

    [key: string]: any;
}

export class SignInResponseDto implements ISignInResponseDto {
    accessToken!: string;

    [key: string]: any;

    constructor(data?: ISignInResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): SignInResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignInResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface ISignInResponseDto {
    accessToken: string;

    [key: string]: any;
}

export class SignInDto implements ISignInDto {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: ISignInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignInDto {
    email: string;
    password: string;

    [key: string]: any;
}

export class UserCustomers implements IUserCustomers {
    customerId!: string;
    customerName!: string;
    roleId!: number;
    roleName!: string;

    [key: string]: any;

    constructor(data?: IUserCustomers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserCustomers {
        data = typeof data === 'object' ? data : {};
        let result = new UserCustomers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserCustomers {
    customerId: string;
    customerName: string;
    roleId: number;
    roleName: string;

    [key: string]: any;
}

export class UserProfileResponseDto implements IUserProfileResponseDto {
    id!: string;
    name!: string;
    email!: string;
    userCustomers!: UserCustomers[];

    [key: string]: any;

    constructor(data?: IUserProfileResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            if (Array.isArray(_data["userCustomers"])) {
                this.userCustomers = [] as any;
                for (let item of _data["userCustomers"])
                    this.userCustomers!.push(UserCustomers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserProfileResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        if (Array.isArray(this.userCustomers)) {
            data["userCustomers"] = [];
            for (let item of this.userCustomers)
                data["userCustomers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserProfileResponseDto {
    id: string;
    name: string;
    email: string;
    userCustomers: UserCustomers[];

    [key: string]: any;
}

export class CreateUserRequestDto implements ICreateUserRequestDto {
    file!: string;
    roleId!: number;
    title!: string;
    name!: string;
    email!: string;
    telephone!: string;
    mobile!: string;
    note!: string;
    emailNotification!: boolean;
    createInspection!: boolean;
    customerId!: string;
    addressLine1!: string;
    addressLine2!: string;
    city!: string;
    county!: string;
    postCode!: string;
    country!: string;

    [key: string]: any;

    constructor(data?: ICreateUserRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
            this.roleId = _data["roleId"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.mobile = _data["mobile"];
            this.note = _data["note"];
            this.emailNotification = _data["emailNotification"];
            this.createInspection = _data["createInspection"];
            this.customerId = _data["customerId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.postCode = _data["postCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): CreateUserRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        data["roleId"] = this.roleId;
        data["title"] = this.title;
        data["name"] = this.name;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["mobile"] = this.mobile;
        data["note"] = this.note;
        data["emailNotification"] = this.emailNotification;
        data["createInspection"] = this.createInspection;
        data["customerId"] = this.customerId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["county"] = this.county;
        data["postCode"] = this.postCode;
        data["country"] = this.country;
        return data;
    }
}

export interface ICreateUserRequestDto {
    file: string;
    roleId: number;
    title: string;
    name: string;
    email: string;
    telephone: string;
    mobile: string;
    note: string;
    emailNotification: boolean;
    createInspection: boolean;
    customerId: string;
    addressLine1: string;
    addressLine2: string;
    city: string;
    county: string;
    postCode: string;
    country: string;

    [key: string]: any;
}

export class UserInfoDto implements IUserInfoDto {
    id!: string;
    name!: string;
    email!: string;
    mobile!: string;

    [key: string]: any;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        return data;
    }
}

export interface IUserInfoDto {
    id: string;
    name: string;
    email: string;
    mobile: string;

    [key: string]: any;
}

export class UserListDtoResponse implements IUserListDtoResponse {
    id!: string;
    roleId!: number;
    user!: UserInfoDto;

    [key: string]: any;

    constructor(data?: IUserListDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserInfoDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? UserInfoDto.fromJS(_data["user"]) : new UserInfoDto();
        }
    }

    static fromJS(data: any): UserListDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserListDtoResponse {
    id: string;
    roleId: number;
    user: UserInfoDto;

    [key: string]: any;
}

export class PaginationMeta implements IPaginationMeta {
    itemCount!: number;
    totalItems!: number;
    itemsPerPage!: number;
    totalPages!: number;
    currentPage!: number;

    [key: string]: any;

    constructor(data?: IPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.itemCount = _data["itemCount"];
            this.totalItems = _data["totalItems"];
            this.itemsPerPage = _data["itemsPerPage"];
            this.totalPages = _data["totalPages"];
            this.currentPage = _data["currentPage"];
        }
    }

    static fromJS(data: any): PaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["itemCount"] = this.itemCount;
        data["totalItems"] = this.totalItems;
        data["itemsPerPage"] = this.itemsPerPage;
        data["totalPages"] = this.totalPages;
        data["currentPage"] = this.currentPage;
        return data;
    }
}

export interface IPaginationMeta {
    itemCount: number;
    totalItems: number;
    itemsPerPage: number;
    totalPages: number;
    currentPage: number;

    [key: string]: any;
}

export class UserPaginationResponseDto implements IUserPaginationResponseDto {
    items!: UserListDtoResponse[];
    meta!: PaginationMeta;

    [key: string]: any;

    constructor(data?: IUserPaginationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
            this.meta = new PaginationMeta();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDtoResponse.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : new PaginationMeta();
        }
    }

    static fromJS(data: any): UserPaginationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaginationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserPaginationResponseDto {
    items: UserListDtoResponse[];
    meta: PaginationMeta;

    [key: string]: any;
}

export class UserPaginationResponse implements IUserPaginationResponse {
    data!: UserPaginationResponseDto;
    success!: boolean;
    statusCode!: number;
    message!: string;

    [key: string]: any;

    constructor(data?: IUserPaginationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new UserPaginationResponseDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? UserPaginationResponseDto.fromJS(_data["data"]) : new UserPaginationResponseDto();
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UserPaginationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserPaginationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        return data;
    }
}

export interface IUserPaginationResponse {
    data: UserPaginationResponseDto;
    success: boolean;
    statusCode: number;
    message: string;

    [key: string]: any;
}

export class GetUserRequestDto implements IGetUserRequestDto {
    page!: number;
    take!: number;
    searchTerm!: string;

    [key: string]: any;

    constructor(data?: IGetUserRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.page = 1;
            this.take = 10;
            this.searchTerm = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.page = _data["page"] !== undefined ? _data["page"] : 1;
            this.take = _data["take"] !== undefined ? _data["take"] : 10;
            this.searchTerm = _data["searchTerm"] !== undefined ? _data["searchTerm"] : "";
        }
    }

    static fromJS(data: any): GetUserRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["page"] = this.page;
        data["take"] = this.take;
        data["searchTerm"] = this.searchTerm;
        return data;
    }
}

export interface IGetUserRequestDto {
    page: number;
    take: number;
    searchTerm: string;

    [key: string]: any;
}

export class InspectionRequestDto implements IInspectionRequestDto {
    id!: string;

    [key: string]: any;

    constructor(data?: IInspectionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.id = "0";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : "0";
        }
    }

    static fromJS(data: any): InspectionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IInspectionRequestDto {
    id: string;

    [key: string]: any;
}

export class PropertyRequestDto implements IPropertyRequestDto {
    id!: string;
    referenceNo!: string;
    addressLine1!: string;
    addressLine2!: string;
    city!: string;
    county!: string;
    postCode!: string;
    country!: string;
    latitude!: string;
    longitude!: string;
    noOfBeds!: number;
    noOfBaths!: number;
    noOfGarages!: number;
    hasParking!: boolean;
    hasGarden!: boolean;
    uprn!: string;
    parentPropertyId!: string;
    notes!: string;
    epcRating!: string;
    transferPastInspection!: boolean;
    additionalAreas!: number;
    hasGarage!: boolean;
    furnishType!: number;
    propertyType!: number;
    detachmentType!: number;
    imageUrl!: string;
    clientId!: string;

    [key: string]: any;

    constructor(data?: IPropertyRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.id = "0";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : "0";
            this.referenceNo = _data["referenceNo"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.postCode = _data["postCode"];
            this.country = _data["country"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.noOfBeds = _data["noOfBeds"];
            this.noOfBaths = _data["noOfBaths"];
            this.noOfGarages = _data["noOfGarages"];
            this.hasParking = _data["hasParking"];
            this.hasGarden = _data["hasGarden"];
            this.uprn = _data["uprn"];
            this.parentPropertyId = _data["parentPropertyId"];
            this.notes = _data["notes"];
            this.epcRating = _data["epcRating"];
            this.transferPastInspection = _data["transferPastInspection"];
            this.additionalAreas = _data["additionalAreas"];
            this.hasGarage = _data["hasGarage"];
            this.furnishType = _data["furnishType"];
            this.propertyType = _data["propertyType"];
            this.detachmentType = _data["detachmentType"];
            this.imageUrl = _data["imageUrl"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): PropertyRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["referenceNo"] = this.referenceNo;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["county"] = this.county;
        data["postCode"] = this.postCode;
        data["country"] = this.country;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["noOfBeds"] = this.noOfBeds;
        data["noOfBaths"] = this.noOfBaths;
        data["noOfGarages"] = this.noOfGarages;
        data["hasParking"] = this.hasParking;
        data["hasGarden"] = this.hasGarden;
        data["uprn"] = this.uprn;
        data["parentPropertyId"] = this.parentPropertyId;
        data["notes"] = this.notes;
        data["epcRating"] = this.epcRating;
        data["transferPastInspection"] = this.transferPastInspection;
        data["additionalAreas"] = this.additionalAreas;
        data["hasGarage"] = this.hasGarage;
        data["furnishType"] = this.furnishType;
        data["propertyType"] = this.propertyType;
        data["detachmentType"] = this.detachmentType;
        data["imageUrl"] = this.imageUrl;
        data["clientId"] = this.clientId;
        return data;
    }
}

export interface IPropertyRequestDto {
    id: string;
    referenceNo: string;
    addressLine1: string;
    addressLine2: string;
    city: string;
    county: string;
    postCode: string;
    country: string;
    latitude: string;
    longitude: string;
    noOfBeds: number;
    noOfBaths: number;
    noOfGarages: number;
    hasParking: boolean;
    hasGarden: boolean;
    uprn: string;
    parentPropertyId: string;
    notes: string;
    epcRating: string;
    transferPastInspection: boolean;
    additionalAreas: number;
    hasGarage: boolean;
    furnishType: number;
    propertyType: number;
    detachmentType: number;
    imageUrl: string;
    clientId: string;

    [key: string]: any;
}

export class PropertyListDtoResponse implements IPropertyListDtoResponse {
    id!: string;
    addressLine1!: string;
    addressLine2!: string;
    city!: string;
    county!: string;
    postCode!: string;
    country!: string;
    noOfBeds!: number;
    noOfBaths!: number;
    noOfGarages!: number;
    hasParking!: boolean;
    hasGarden!: boolean;
    hasGarage!: boolean;

    [key: string]: any;

    constructor(data?: IPropertyListDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.postCode = _data["postCode"];
            this.country = _data["country"];
            this.noOfBeds = _data["noOfBeds"];
            this.noOfBaths = _data["noOfBaths"];
            this.noOfGarages = _data["noOfGarages"];
            this.hasParking = _data["hasParking"];
            this.hasGarden = _data["hasGarden"];
            this.hasGarage = _data["hasGarage"];
        }
    }

    static fromJS(data: any): PropertyListDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyListDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["county"] = this.county;
        data["postCode"] = this.postCode;
        data["country"] = this.country;
        data["noOfBeds"] = this.noOfBeds;
        data["noOfBaths"] = this.noOfBaths;
        data["noOfGarages"] = this.noOfGarages;
        data["hasParking"] = this.hasParking;
        data["hasGarden"] = this.hasGarden;
        data["hasGarage"] = this.hasGarage;
        return data;
    }
}

export interface IPropertyListDtoResponse {
    id: string;
    addressLine1: string;
    addressLine2: string;
    city: string;
    county: string;
    postCode: string;
    country: string;
    noOfBeds: number;
    noOfBaths: number;
    noOfGarages: number;
    hasParking: boolean;
    hasGarden: boolean;
    hasGarage: boolean;

    [key: string]: any;
}

export class PropertyPaginationResponseDto implements IPropertyPaginationResponseDto {
    items!: PropertyListDtoResponse[];
    meta!: PaginationMeta;

    [key: string]: any;

    constructor(data?: IPropertyPaginationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
            this.meta = new PaginationMeta();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PropertyListDtoResponse.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : new PaginationMeta();
        }
    }

    static fromJS(data: any): PropertyPaginationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyPaginationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyPaginationResponseDto {
    items: PropertyListDtoResponse[];
    meta: PaginationMeta;

    [key: string]: any;
}

export class PropertyPaginationResponse implements IPropertyPaginationResponse {
    data!: PropertyPaginationResponseDto;
    success!: boolean;
    statusCode!: number;
    message!: string;

    [key: string]: any;

    constructor(data?: IPropertyPaginationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new PropertyPaginationResponseDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? PropertyPaginationResponseDto.fromJS(_data["data"]) : new PropertyPaginationResponseDto();
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PropertyPaginationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyPaginationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        return data;
    }
}

export interface IPropertyPaginationResponse {
    data: PropertyPaginationResponseDto;
    success: boolean;
    statusCode: number;
    message: string;

    [key: string]: any;
}

export class PaginationRequest implements IPaginationRequest {
    page!: number;
    take!: number;
    searchTerm!: string;

    [key: string]: any;

    constructor(data?: IPaginationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.page = 1;
            this.take = 10;
            this.searchTerm = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.page = _data["page"] !== undefined ? _data["page"] : 1;
            this.take = _data["take"] !== undefined ? _data["take"] : 10;
            this.searchTerm = _data["searchTerm"] !== undefined ? _data["searchTerm"] : "";
        }
    }

    static fromJS(data: any): PaginationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["page"] = this.page;
        data["take"] = this.take;
        data["searchTerm"] = this.searchTerm;
        return data;
    }
}

export interface IPaginationRequest {
    page: number;
    take: number;
    searchTerm: string;

    [key: string]: any;
}

export class CreateCustomerDto implements ICreateCustomerDto {

    [key: string]: any;

    constructor(data?: ICreateCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CreateCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ICreateCustomerDto {

    [key: string]: any;
}

export class ClientDto implements IClientDto {
    id!: string;
    title!: string;
    name!: string;
    email!: string;
    company!: string;
    telephone!: string;
    mobile!: string;
    addressLine1!: string;
    addressLine2!: string;
    city!: string;
    county!: string;
    postCode!: string;
    country!: string;
    website!: string;
    emailNotification!: boolean;
    companyNo!: string;
    vat!: string;
    billingEmail!: string;
    logoUrl!: string;
    additionalEmails!: string;
    showInvoice!: boolean;
    defaultInvoicePayee!: number;
    showIntegrations!: boolean;
    allowCreateInspection!: boolean;
    allowEditAppointments!: boolean;
    showClerkInfo!: boolean;
    notes!: string;

    [key: string]: any;

    constructor(data?: IClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.title = _data["title"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.company = _data["company"];
            this.telephone = _data["telephone"];
            this.mobile = _data["mobile"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.postCode = _data["postCode"];
            this.country = _data["country"];
            this.website = _data["website"];
            this.emailNotification = _data["emailNotification"];
            this.companyNo = _data["companyNo"];
            this.vat = _data["vat"];
            this.billingEmail = _data["billingEmail"];
            this.logoUrl = _data["logoUrl"];
            this.additionalEmails = _data["additionalEmails"];
            this.showInvoice = _data["showInvoice"];
            this.defaultInvoicePayee = _data["defaultInvoicePayee"];
            this.showIntegrations = _data["showIntegrations"];
            this.allowCreateInspection = _data["allowCreateInspection"];
            this.allowEditAppointments = _data["allowEditAppointments"];
            this.showClerkInfo = _data["showClerkInfo"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["title"] = this.title;
        data["name"] = this.name;
        data["email"] = this.email;
        data["company"] = this.company;
        data["telephone"] = this.telephone;
        data["mobile"] = this.mobile;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["county"] = this.county;
        data["postCode"] = this.postCode;
        data["country"] = this.country;
        data["website"] = this.website;
        data["emailNotification"] = this.emailNotification;
        data["companyNo"] = this.companyNo;
        data["vat"] = this.vat;
        data["billingEmail"] = this.billingEmail;
        data["logoUrl"] = this.logoUrl;
        data["additionalEmails"] = this.additionalEmails;
        data["showInvoice"] = this.showInvoice;
        data["defaultInvoicePayee"] = this.defaultInvoicePayee;
        data["showIntegrations"] = this.showIntegrations;
        data["allowCreateInspection"] = this.allowCreateInspection;
        data["allowEditAppointments"] = this.allowEditAppointments;
        data["showClerkInfo"] = this.showClerkInfo;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IClientDto {
    id: string;
    title: string;
    name: string;
    email: string;
    company: string;
    telephone: string;
    mobile: string;
    addressLine1: string;
    addressLine2: string;
    city: string;
    county: string;
    postCode: string;
    country: string;
    website: string;
    emailNotification: boolean;
    companyNo: string;
    vat: string;
    billingEmail: string;
    logoUrl: string;
    additionalEmails: string;
    showInvoice: boolean;
    defaultInvoicePayee: number;
    showIntegrations: boolean;
    allowCreateInspection: boolean;
    allowEditAppointments: boolean;
    showClerkInfo: boolean;
    notes: string;

    [key: string]: any;
}

export class ClientListDtoResponse implements IClientListDtoResponse {
    id!: string;
    name!: string;
    email!: string;
    company!: string;
    telephone!: string;
    addressLine1!: string;
    addressLine2!: string;
    city!: string;
    county!: string;
    postCode!: string;
    country!: string;

    [key: string]: any;

    constructor(data?: IClientListDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.company = _data["company"];
            this.telephone = _data["telephone"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.postCode = _data["postCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): ClientListDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["company"] = this.company;
        data["telephone"] = this.telephone;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["county"] = this.county;
        data["postCode"] = this.postCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IClientListDtoResponse {
    id: string;
    name: string;
    email: string;
    company: string;
    telephone: string;
    addressLine1: string;
    addressLine2: string;
    city: string;
    county: string;
    postCode: string;
    country: string;

    [key: string]: any;
}

export class ClientPaginationResponseDto implements IClientPaginationResponseDto {
    items!: ClientListDtoResponse[];
    meta!: PaginationMeta;

    [key: string]: any;

    constructor(data?: IClientPaginationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
            this.meta = new PaginationMeta();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientListDtoResponse.fromJS(item));
            }
            this.meta = _data["meta"] ? PaginationMeta.fromJS(_data["meta"]) : new PaginationMeta();
        }
    }

    static fromJS(data: any): ClientPaginationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPaginationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientPaginationResponseDto {
    items: ClientListDtoResponse[];
    meta: PaginationMeta;

    [key: string]: any;
}

export class ClientPaginationResponse implements IClientPaginationResponse {
    data!: ClientPaginationResponseDto;
    success!: boolean;
    statusCode!: number;
    message!: string;

    [key: string]: any;

    constructor(data?: IClientPaginationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new ClientPaginationResponseDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? ClientPaginationResponseDto.fromJS(_data["data"]) : new ClientPaginationResponseDto();
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ClientPaginationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPaginationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        return data;
    }
}

export interface IClientPaginationResponse {
    data: ClientPaginationResponseDto;
    success: boolean;
    statusCode: number;
    message: string;

    [key: string]: any;
}

export class ContactRequestDto implements IContactRequestDto {
    id!: string;
    name!: string;
    email!: string;
    mobile!: string;
    isSignee!: boolean;
    notifyConductDate!: boolean;
    canDeliverReport!: boolean;
    title!: string;
    telephone!: string;
    note!: string;
    inspectionId!: string;

    [key: string]: any;

    constructor(data?: IContactRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.id = "0";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : "0";
            this.name = _data["name"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.isSignee = _data["isSignee"];
            this.notifyConductDate = _data["notifyConductDate"];
            this.canDeliverReport = _data["canDeliverReport"];
            this.title = _data["title"];
            this.telephone = _data["telephone"];
            this.note = _data["note"];
            this.inspectionId = _data["inspectionId"];
        }
    }

    static fromJS(data: any): ContactRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["isSignee"] = this.isSignee;
        data["notifyConductDate"] = this.notifyConductDate;
        data["canDeliverReport"] = this.canDeliverReport;
        data["title"] = this.title;
        data["telephone"] = this.telephone;
        data["note"] = this.note;
        data["inspectionId"] = this.inspectionId;
        return data;
    }
}

export interface IContactRequestDto {
    id: string;
    name: string;
    email: string;
    mobile: string;
    isSignee: boolean;
    notifyConductDate: boolean;
    canDeliverReport: boolean;
    title: string;
    telephone: string;
    note: string;
    inspectionId: string;

    [key: string]: any;
}

export class ContactResponseDto implements IContactResponseDto {
    id!: string;
    name!: string;
    email!: string;
    mobile!: string;
    isSignee!: boolean;
    notifyConductDate!: boolean;
    canDeliverReport!: boolean;
    inspectionId!: string;

    [key: string]: any;

    constructor(data?: IContactResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.isSignee = _data["isSignee"];
            this.notifyConductDate = _data["notifyConductDate"];
            this.canDeliverReport = _data["canDeliverReport"];
            this.inspectionId = _data["inspectionId"];
        }
    }

    static fromJS(data: any): ContactResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["isSignee"] = this.isSignee;
        data["notifyConductDate"] = this.notifyConductDate;
        data["canDeliverReport"] = this.canDeliverReport;
        data["inspectionId"] = this.inspectionId;
        return data;
    }
}

export interface IContactResponseDto {
    id: string;
    name: string;
    email: string;
    mobile: string;
    isSignee: boolean;
    notifyConductDate: boolean;
    canDeliverReport: boolean;
    inspectionId: string;

    [key: string]: any;
}

export class Anonymous extends CustomResponse implements IAnonymous {
    data!: SignInResponseDto;

    [key: string]: any;

    constructor(data?: IAnonymous) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? SignInResponseDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous extends ICustomResponse {
    data: SignInResponseDto;

    [key: string]: any;
}

export class Anonymous2 extends CustomResponse implements IAnonymous2 {
    data!: UserProfileResponseDto;

    [key: string]: any;

    constructor(data?: IAnonymous2) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? UserProfileResponseDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous2 extends ICustomResponse {
    data: UserProfileResponseDto;

    [key: string]: any;
}

export class Anonymous3 extends CustomResponse implements IAnonymous3 {
    data!: InspectionRequestDto;

    [key: string]: any;

    constructor(data?: IAnonymous3) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? InspectionRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous3 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous3 extends ICustomResponse {
    data: InspectionRequestDto;

    [key: string]: any;
}

export class Anonymous4 extends CustomResponse implements IAnonymous4 {
    data!: PropertyRequestDto;

    [key: string]: any;

    constructor(data?: IAnonymous4) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? PropertyRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous4 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous4 extends ICustomResponse {
    data: PropertyRequestDto;

    [key: string]: any;
}

export class Anonymous5 extends CustomResponse implements IAnonymous5 {
    data!: ClientDto;

    [key: string]: any;

    constructor(data?: IAnonymous5) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? ClientDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous5 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous5 extends ICustomResponse {
    data: ClientDto;

    [key: string]: any;
}

export class Anonymous6 extends CustomResponse implements IAnonymous6 {
    data!: ContactRequestDto;

    [key: string]: any;

    constructor(data?: IAnonymous6) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? ContactRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous6 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous6 extends ICustomResponse {
    data: ContactRequestDto;

    [key: string]: any;
}

export class Anonymous7 extends CustomResponse implements IAnonymous7 {
    data!: ContactResponseDto;

    [key: string]: any;

    constructor(data?: IAnonymous7) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"] ? ContactResponseDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous7 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnonymous7 extends ICustomResponse {
    data: ContactResponseDto;

    [key: string]: any;
}
//-----/CustomTypes.File-----

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

//-----/Types.File-----

import { addResultTypeFactory } from './axios-client/helpers';
export { setBaseUrl, getBaseUrl } from './axios-client/helpers';
export { setAxiosFactory, getAxios } from './axios-client/helpers';


//-----PersistorHydrator.File-----
import type { PersistedClient } from '@tanstack/react-query-persist-client';
import type { DehydratedState, QueryKey } from '@tanstack/react-query'
import { getResultTypeFactory } from './axios-client/helpers';

/*
 * If you have Dates in QueryKeys (i.e. in request parameters), you need to deserialize them to Dates correctly
 * (otherwise they are deserialized as strings by default, and your queries are broken).
 */
export function deserializeDate(str: unknown) {
  if (!str || typeof str !== 'string') return str;
  if (!/^\d\d\d\d\-\d\d\-\d\d/.test(str)) return str;
  
  const date = new Date(str);
  const isDate = date instanceof Date && !isNaN(date as any);
  
  return isDate ? date : str;
}

export function deserializeDatesInQueryKeys(queryKey: QueryKey) {
  return queryKey
    // We need to replace `null` with `undefined` in query key, because
    // `undefined` is serialized as `null`.
    // And most probably if we have `null` in QueryKey it actually means `undefined`.
    // We can't keep nulls, because they have a different meaning, and e.g. boolean parameters are not allowed to be null.
    .map(x => (x === null ? undefined : x))
    .map(x => deserializeDate(x));
}

export function deserializeClassesInQueryData(queryKey: QueryKey, data: any) {
  if (!data) {
    return data;
  } else if (typeof data !== 'object') {
    return data;
  } else if ('pages' in data && 'pageParams' in data && Array.isArray(data.pages) && Array.isArray(data.pageParams)) {
    // infinite query
    data.pages = data.pages.map((page:any) => deserializeClassesInQueryData(queryKey, page));
  } else if (Array.isArray(data)) {
    return data.map(elem => constructDtoClass(queryKey, elem));
  } else {
    return constructDtoClass(queryKey, data);
  }
}

/*
 * Pass this function as `deserialize` option to createSyncStoragePersister/createAsyncStoragePersister
 * to correctly deserialize your DTOs (including Dates)
 */
export function persisterDeserialize(cache: string): PersistedClient {
  const client: PersistedClient = JSON.parse(cache);
  client.clientState.queries.forEach((query) => {
    query.state.data = deserializeClassesInQueryData(query.queryKey, query.state.data);
    query.queryKey = deserializeDatesInQueryKeys(query.queryKey);
  });

  return client;
}

export function constructDtoClass(queryKey: QueryKey, data: any): unknown {
  const resultTypeKey = getResultTypeClassKey(queryKey);
  const constructorFunction = getResultTypeFactory(resultTypeKey);

  if (!data || !constructorFunction)
    return data;

  return constructorFunction(data);
}

export function getResultTypeClassKey(queryKey: QueryKey): string {
  if (!Array.isArray(queryKey)) {
    return queryKey as unknown as string;
  }
  if (queryKey.length >= 2) {
    // We concatenate first and second elements, because they uniquely identify the query.
    // All other QueryKey elements are query parameters
    return `${queryKey[0]}___${queryKey[1]}`;
  }

  // We actually should never reach this point :)
  return queryKey.join('___');
}

export function initPersister() {
  
  addResultTypeFactory('AuthControllerClient___getMe', (data: any) => { const result = new Anonymous2(); result.init(data); return result; });












  addResultTypeFactory('ContactControllerClient___getContacts', (data: any) => { const result = new Anonymous7(); result.init(data); return result; });




}
//-----/PersistorHydrator.File----